union Proc s r =
    view (s -> Proc s r)       |
    update (s -> s) (Proc s r) |
    return r                    |

func return : (s -> a) -> Proc s a =
    \f
    view \x
    return (f x)

func -> : (s -> a) -> (a -> Proc s r) -> Proc s r =
    \viewer \fnext
    view (fnext . viewer)

func := : ((a -> a) -> s -> s) -> a -> Proc s r -> Proc s r =
    \accessor \value \next
    update (accessor (const value));
    next

func := : ((a -> a) -> s -> s) -> (s -> a) -> Proc s r -> Proc s r =
    \accessor \viewer \next
    update (\s accessor (const (viewer s)) s);
    next

func <- : ((a -> a) -> s -> s) -> (a -> a) -> Proc s r -> Proc s r =
    \accessor \f \next
    update (accessor f);
    next

func start-with : s -> Proc s r -> r =
    \value \Proc
    switch Proc
    case view \f
        start-with value;
        f value
    case update \f \next
        start-with (strict f value);
        next
    case return \x
        x

func call : Proc s a -> (a -> Proc s b) -> Proc s b =
    \Proc \fnext
    switch Proc
    case view \f
        view \s
        call (f s) fnext
    case update \f \next
        update f;
        call next fnext
    case return \x
        fnext x

func while : (s -> Bool) -> (Proc s a -> Proc s a) -> Proc s a -> Proc s a =
    \cond \body \next
    view \s
    if (not cond s) next;
    body;
    while cond body;
    next
