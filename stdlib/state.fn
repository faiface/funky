union State s r =
    view (s -> State s r)       |
    update (s -> s) (State s r) |
    return r                    |

func return : (s -> a) -> State s a =
    \f
    view \x
    return (f x)

func -> : (s -> a) -> (a -> State s r) -> State s r =
    \viewer \fnext
    view (fnext . viewer)

func := : ((a -> a) -> s -> s) -> a -> State s r -> State s r =
    \accessor \value \next
    update (accessor (const value));
    next

func := : ((a -> a) -> s -> s) -> (s -> a) -> State s r -> State s r =
    \accessor \viewer \next
    update (\s accessor (const (viewer s)) s);
    next

func <- : ((a -> a) -> s -> s) -> (a -> a) -> State s r -> State s r =
    \accessor \f \next
    update (accessor f);
    next

func start-with : s -> State s r -> r =
    \value \state
    switch state
    case view \f
        start-with value;
        f value
    case update \f \next
        start-with (strict f value);
        next
    case return \x
        x

func call : State s a -> (a -> State s b) -> State s b =
    \state \fnext
    switch state
    case view \f
        view \s
        call (f s) fnext
    case update \f \next
        update f;
        call next fnext
    case return \x
        fnext x

func while : (s -> Bool) -> (State s a -> State s a) -> State s a -> State s a =
    \cond \body \next
    view \s
    if (not cond s) next;
    body;
    while cond body;
    next
